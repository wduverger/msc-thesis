"""
The code below is a wrapper around the bioinformatics package for easier
reading of bioformats files such as those generated by 
the Tegenfeldt STED microscope.

Written by Wouter Duverger (2021)

Usage:
    import utils
    images = utils.read_msr(filepath)
    utils.shutdown_jvm()  # Avoid memory leaks if not running in notebook
"""

import bioformats as bf
import javabridge
import numpy as np


def read_msr(path):
    """
    Read all images inside a single .msr file.
    Returns a dict that maps channel names to 3D image stacks, 
    including microscope metadata
    """

    # Bioformats requires a running Java VM
    MyJvm.start_if_not_running()

    # These dicts will be filled and returned to the caller
    images_dict = {}

    # Get the metadata from the image file
    metadata = bf.OMEXML(bf.get_omexml_metadata(path))

    # Construct an image reader instance
    reader = bf.get_image_reader(key=path, path=path)

    # Loop over all images inside the msr
    for i in range(metadata.image_count):

        # Get information on that image
        img_meta = metadata.image(i)
        image_name = img_meta.Name
        plane_count = img_meta.Pixels.SizeZ

        # Read all z planes in the image (as 2D numpy arrays)
        # and put them in a list
        plane_list = []
        for z in range(plane_count):
            plane_list.append(reader.read(series=i, z=z))
        img_array = np.array(plane_list)

        # Convert the list of numpy arrays to a 3D numpy array
        # and store it in the dict, with the channel name as key
        images_dict[image_name] = BFImageArray(img_array, img_meta)

    # Return the images
    return images_dict

class BFImageArray(np.ndarray):
    """
    Subclass of numpy.ndarray that adds some properties for easier access 
    to metadata. All bioformats metadata can be accessed using the `meta`
    property, but pixel size and image origins are also present as
    individual properties. 

    Credits to https://numpy.org/doc/stable/user/basics.subclassing.html
    """

    def __new__(cls, input_array, meta):

        # Generate an array object with the right data in our class type
        obj = np.asarray(input_array).view(cls)

        # Add the new attributes to the created instance
        obj.meta = meta
        obj.pixel_size_xy = meta.Pixels.PhysicalSizeX
        obj.origin_x = meta.Pixels.Plane().PositionX
        obj.origin_y = meta.Pixels.Plane().PositionY

        # Return the object
        return obj

    def __array_finalize__(self, obj):
        # See docs referred to above for details of this method
        
        if obj is None:
            return
        
        self.meta          = getattr(obj, 'meta', None)
        self.pixel_size_xy = getattr(obj, 'pixel_size_xy', None)
        self.origin_x      = getattr(obj, 'origin_x', None)
        self.origin_y      = getattr(obj, 'origin_y', None)


class MyJvm:

    _did_start_vm = False

    @classmethod
    def start_if_not_running(cls):
        if not MyJvm._did_start_vm:
            javabridge.kill_vm()

            javabridge.start_vm(class_path=bf.JARS)
            MyJvm._did_start_vm = True


def shutdown_jvm():
    javabridge.kill_vm()
    MyJvm._did_start_vm = False
