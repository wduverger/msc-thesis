from datetime import datetime, timedelta

import numpy as np
import pandas as pd
import scipy.signal

from mpl_toolkits.axes_grid1.anchored_artists import AnchoredSizeBar

from .bioformats import read_msr, shutdown_jvm
from .data_analysis import pol_to_rgb, align


def add_scalebar(
    axis, 
    len_in_pixels, 
    label=None, 
    position='upper right', 
    color='white', 
    frameon=False,
    pad=.3,
    size_vertical=2,
    **kwargs
):
    axis.add_artist(AnchoredSizeBar(
        axis.transData,
        len_in_pixels,
        label, 
        position, 
        color='white',
        frameon=False,
        size_vertical=size_vertical,
        pad=pad,
        **kwargs
    ))


def read_power_data(path):
    """
    Read a csv file generated by the power meter into a pandas dataframe with the following columns
    - t: time since start of measurement (in seconds)
    - p: power measured at time t (in Watts)
    - dp: difference in power between the measurement at time t and the measurement before it
    """

    data = pd.read_csv(
        path,
        engine='python',
        sep=r';\s?',
        names=['date', 'time', 'p'],
        header=4,
        skipfooter=8
    )
    
    parsetime = lambda x: datetime.strptime(x, '%H:%M:%S.%f') 
    data['t'] = (data.time.map(parsetime) - parsetime(data.time[0])).map(timedelta.total_seconds)
    data['dp'] = np.hstack((np.nan, np.diff(data.p)))
    return data

def moving_average(array, n) :
    return pd.Series(array).rolling(n).mean().values

def find_steps(y, average_window=100, **peaks_kwarg):
    """
    Fit a stepwise function to an array of function values, by locating peaks in the derivative
    """

    dy = np.abs(moving_average(np.diff(y), average_window))
    peaks, _ = scipy.signal.find_peaks(dy, **peaks_kwarg)

    left_bounds = np.hstack([0, peaks])
    right_bounds = np.hstack([peaks, -1])
    p_means = [
        y[ l+average_window : r-average_window ].mean() 
        for l, r in zip(left_bounds, right_bounds)
    ]
    p_stds = [
        y[ l+average_window : r-average_window ].std() 
        for l, r in zip(left_bounds, right_bounds)
    ]
    
    return left_bounds, np.array(p_means), np.array(p_stds)

